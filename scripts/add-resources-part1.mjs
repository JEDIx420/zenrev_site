import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const newResources = [
    {
        slug: "n8n-mcp-bridge-agentic-workflows",
        title: "How the New n8n MCP Bridge Transforms Agentic Workflows with ChatGPT, Claude, and Gemini",
        description: "A breakdown of how MCP unlocks deeper tool-calling, real-time orchestration, and multi-agent GTM systems.",
        client: "Technical Deep Dive",
        industry: "AI Infrastructure",
        metrics: [
            { label: "Integration Speed", value: "10x Faster" },
            { label: "Tool Reliability", value: "99.9%" },
            { label: "Agent Coordination", value: "Real-time" }
        ],
        quote: "MCP is the missing protocol that makes AI agents actually useful in production GTM workflows.",
        author: "zenrev Engineering",
        outcomeSnapshot: "The Model Context Protocol (MCP) bridges the gap between LLMs and real-world tools, enabling ChatGPT, Claude, and Gemini to orchestrate complex GTM workflows through n8n with unprecedented reliability and speed.",
        metadata: {
            title: "n8n MCP Bridge for Agentic Workflows | ChatGPT, Claude, Gemini Integration",
            description: "Learn how the Model Context Protocol transforms AI agents into production-ready GTM orchestrators with n8n integration.",
            keywords: ["n8n MCP bridge", "agentic workflows", "ChatGPT integration", "Claude automation", "Gemini orchestration", "Model Context Protocol", "AI tool calling", "multi-agent systems"]
        },
        content: `<h2>The Protocol That Changes Everything</h2><p>For years, AI agents have been impressive demos but frustrating in production. They hallucinate tool calls, break on edge cases, and require constant babysitting. The <strong>Model Context Protocol (MCP)</strong> changes this by providing a standardized way for LLMs to interact with external tools and data sources.</p><p>When combined with n8n's workflow automation, MCP creates a bridge between the reasoning capabilities of frontier models (ChatGPT, Claude, Gemini) and the operational reality of your GTM stack. This isn't just another integration—it's a fundamental shift in how AI agents operate.</p><h2>What is MCP and Why Does It Matter?</h2><p>MCP is an open protocol developed by Anthropic that defines how AI models should communicate with tools, APIs, and data sources. Think of it as the HTTP of AI tool-calling—a universal standard that ensures reliability and interoperability.</p><h3>The Problem MCP Solves</h3><p>Before MCP, every AI integration was custom-built:</p><ul><li><strong>Fragile connections:</strong> Each tool required bespoke code to handle authentication, error states, and data formatting</li><li><strong>No standardization:</strong> Moving from ChatGPT to Claude meant rewriting everything</li><li><strong>Poor observability:</strong> When things broke, you had no idea why</li><li><strong>Limited coordination:</strong> Multi-agent systems were nearly impossible to orchestrate</li></ul><p>MCP provides a universal interface that handles all of this automatically. Your n8n workflows become callable functions that any MCP-compatible model can invoke with perfect reliability.</p><div class="my-8 p-6 bg-blue-50 rounded-xl border border-blue-100"><h4 class="text-lg font-bold text-brand-blue mb-2">Ready to deploy MCP-powered agents?</h4><p class="mb-4 text-sm text-gray-600">We'll build your n8n MCP bridge and integrate it with your GTM stack.</p><a href="https://cal.com/jayanand-j-ywq8ls/30min" target="_blank" class="inline-block bg-brand-blue text-white px-4 py-2 rounded-lg font-medium hover:bg-blue-700 transition-colors">Book MCP Consultation</a></div><h2>The n8n MCP Bridge Architecture</h2><p>The n8n MCP bridge works by exposing your n8n workflows as MCP-compliant tools. Here's how the architecture flows:</p><ol><li><strong>Tool Registration:</strong> Your n8n workflows are registered in the MCP server with schemas defining inputs, outputs, and error handling</li><li><strong>Agent Invocation:</strong> When ChatGPT, Claude, or Gemini decides to use a tool, it sends a structured request via MCP</li><li><strong>Workflow Execution:</strong> n8n receives the request, executes the workflow, and returns structured results</li><li><strong>Context Preservation:</strong> MCP maintains conversation context across multiple tool calls, enabling complex multi-step workflows</li></ol><h3>Real-World Example: Signal-to-Outreach Pipeline</h3><p>Imagine an agent that monitors funding announcements and automatically initiates personalized outreach:</p><pre><code>1. Agent detects Series B announcement via Exa AI
2. Calls n8n workflow "enrich_company" via MCP
3. n8n fetches data from Clay, Clearbit, LinkedIn
4. Agent analyzes enrichment data
5. Calls n8n workflow "generate_outreach" via MCP
6. n8n creates personalized email using GPT-4
7. Agent reviews and approves
8. Calls n8n workflow "send_and_log" via MCP
9. n8n sends via SendGrid, logs to HubSpot</code></pre><p>This entire flow happens in seconds, with full observability and error handling at every step. The agent makes intelligent decisions while n8n handles the operational complexity.</p><h2>Multi-Agent Orchestration</h2><p>The real power of MCP emerges when you coordinate multiple specialized agents. With the n8n MCP bridge, you can build systems where:</p><ul><li><strong>Research Agent:</strong> Monitors signals and gathers intelligence (Claude Opus for deep analysis)</li><li><strong>Scoring Agent:</strong> Evaluates lead quality and prioritization (GPT-4 for structured decision-making)</li><li><strong>Outreach Agent:</strong> Crafts personalized messaging (Gemini for creative writing)</li><li><strong>Coordinator Agent:</strong> Manages the workflow and handles exceptions (Claude Sonnet for orchestration)</li></ul><p>Each agent calls the same n8n workflows via MCP, but brings different reasoning capabilities to the task. The result is a GTM system that combines the best of each model while maintaining operational consistency.</p><div class="my-8 p-6 bg-gray-50 rounded-xl border border-gray-200"><h4 class="text-lg font-bold text-gray-900 mb-2">See multi-agent systems in action</h4><p class="mb-4 text-sm text-gray-600">Explore our library of pre-built MCP-powered agent workflows.</p><a href="/workflows" class="inline-block bg-white border border-gray-300 text-gray-900 px-4 py-2 rounded-lg font-medium hover:bg-gray-50 transition-colors">View Workflow Library</a></div><h2>Implementation Guide</h2><h3>Step 1: Set Up Your n8n MCP Server</h3><p>Install the n8n MCP bridge package and configure your workflows for MCP exposure. Each workflow needs a schema that defines:</p><ul><li>Input parameters and their types</li><li>Expected output structure</li><li>Error handling behavior</li><li>Authentication requirements</li></ul><h3>Step 2: Register Tools with Your LLM</h3><p>Configure your ChatGPT, Claude, or Gemini instance to recognize your n8n workflows as available tools. The MCP protocol handles the handshake and capability negotiation automatically.</p><h3>Step 3: Build Agent Logic</h3><p>Create your agent prompts with clear instructions on when and how to use each tool. The key is to give agents enough context to make intelligent decisions while constraining them to your approved workflows.</p><h3>Step 4: Monitor and Optimize</h3><p>Use n8n's execution logs combined with MCP's observability features to track agent behavior. Look for patterns in tool usage, error rates, and execution times to continuously improve your system.</p><h2>Production Considerations</h2><p>Running MCP-powered agents in production requires attention to:</p><ul><li><strong>Rate Limiting:</strong> Implement throttling to prevent runaway agent loops</li><li><strong>Cost Control:</strong> Monitor LLM API usage and set budget alerts</li><li><strong>Error Recovery:</strong> Design workflows with graceful degradation and retry logic</li><li><strong>Security:</strong> Use MCP's authentication layer to ensure only authorized agents can call sensitive workflows</li><li><strong>Versioning:</strong> Maintain backward compatibility as you evolve your tool schemas</li></ul><h2>The Future of GTM is Agentic</h2><p>The n8n MCP bridge represents a fundamental shift from "AI-assisted" to "AI-native" GTM operations. Instead of humans using AI tools, we now have AI agents using human-designed workflows to achieve business objectives.</p><p>This isn't science fiction—it's happening now. Companies deploying MCP-powered agents are seeing 10x improvements in speed-to-lead, 60% reductions in operational costs, and the ability to run sophisticated GTM motions that were previously impossible.</p><p>The question isn't whether to adopt this technology, but how quickly you can get it into production.</p>`
    },
    {
        slug: "2025-gtm-engineer-stack",
        title: "The 2025 GTM Engineer's Stack: Clay, n8n, Firecrawl, and Exa AI Working Together",
        description: "A practical guide showing how modern GTM teams integrate enrichment, scraping, and automation into one pipeline.",
        client: "Stack Guide",
        industry: "GTM Engineering",
        metrics: [
            { label: "Tools Integrated", value: "4 Core" },
            { label: "Setup Time", value: "2 Days" },
            { label: "ROI Timeline", value: "Week 1" }
        ],
        quote: "The right stack doesn't just save time—it unlocks GTM motions that were previously impossible.",
        author: "zenrev Stack Team",
        outcomeSnapshot: "Modern GTM engineering requires a tightly integrated stack. Clay for enrichment, n8n for orchestration, Firecrawl for data extraction, and Exa AI for discovery create a pipeline that turns signals into revenue automatically.",
        metadata: {
            title: "The 2025 GTM Engineer's Stack | Clay, n8n, Firecrawl, Exa AI Integration",
            description: "Complete guide to building a modern GTM stack with Clay, n8n, Firecrawl, and Exa AI. Learn integration patterns and workflows.",
            keywords: ["GTM stack 2025", "Clay enrichment", "n8n automation", "Firecrawl scraping", "Exa AI", "GTM engineering tools", "sales automation stack", "revenue operations"]
        },
        content: `<h2>The Modern GTM Stack</h2><p>Gone are the days when a CRM and an email tool were enough. Modern GTM engineering requires a sophisticated stack that can detect signals, enrich data, orchestrate workflows, and execute at scale. The 2025 GTM engineer's stack has four core components:</p><ul><li><strong>Clay:</strong> The enrichment and data transformation layer</li><li><strong>n8n:</strong> The orchestration and automation engine</li><li><strong>Firecrawl:</strong> The web scraping and data extraction tool</li><li><strong>Exa AI:</strong> The intelligent discovery and search platform</li></ul><p>Together, these tools create a pipeline that can run sophisticated GTM motions with minimal human intervention.</p><h2>Clay: The Enrichment Powerhouse</h2><p>Clay is the central nervous system of your data operations. It connects to 50+ data providers (Clearbit, Apollo, LinkedIn, etc.) and lets you build enrichment workflows with a spreadsheet-like interface.</p><h3>What Makes Clay Essential</h3><ul><li><strong>Waterfall enrichment:</strong> Try multiple data sources in sequence until you get the data you need</li><li><strong>Data transformation:</strong> Clean, normalize, and structure data before it hits your CRM</li><li><strong>API integrations:</strong> Connect to any tool via HTTP requests and custom logic</li><li><strong>AI formulas:</strong> Use GPT-4 to analyze and categorize data at scale</li></ul><h3>Common Clay Workflows</h3><p>1. <strong>Company enrichment:</strong> Start with a domain, get firmographics, technographics, and funding data<br>2. <strong>Contact discovery:</strong> Find decision-makers at target accounts with specific titles<br>3. <strong>Signal detection:</strong> Monitor job changes, funding rounds, and hiring patterns<br>4. <strong>Data normalization:</strong> Standardize industry names, company sizes, and locations</p><div class="my-8 p-6 bg-blue-50 rounded-xl border border-blue-100"><h4 class="text-lg font-bold text-brand-blue mb-2">Need help with Clay?</h4><p class="mb-4 text-sm text-gray-600">We build custom Clay tables and enrichment workflows for GTM teams.</p><a href="/clay-expert" class="inline-block bg-brand-blue text-white px-4 py-2 rounded-lg font-medium hover:bg-blue-700 transition-colors">Explore Clay Services</a></div><h2>n8n: The Orchestration Engine</h2><p>n8n is where your GTM logic lives. It's a workflow automation tool that connects all your systems and defines the rules of engagement.</p><h3>Why n8n Over Zapier</h3><ul><li><strong>Self-hosted:</strong> Full control over your data and infrastructure</li><li><strong>Complex logic:</strong> Build sophisticated if/then/else flows with loops and conditionals</li><li><strong>Developer-friendly:</strong> Write custom JavaScript when you need it</li><li><strong>Cost-effective:</strong> No per-task pricing means you can run millions of operations</li></ul><h3>Key n8n Workflows for GTM</h3><p>1. <strong>Signal to outreach:</strong> Detect event → enrich → score → personalize → send<br>2. <strong>Lead routing:</strong> New lead → qualify → assign → notify → create tasks<br>3. <strong>Data sync:</strong> Keep Clay, HubSpot, and Salesforce in perfect sync<br>4. <strong>Report generation:</strong> Pull data from multiple sources, analyze, and send dashboards</p><h2>Firecrawl: The Data Extraction Layer</h2><p>Firecrawl is a modern web scraping tool built for AI-era data extraction. It handles JavaScript rendering, anti-bot protection, and returns clean, structured data.</p><h3>Firecrawl Use Cases</h3><ul><li><strong>Company research:</strong> Extract data from company websites, blogs, and press pages</li><li><strong>Job monitoring:</strong> Track new job postings as buying signals</li><li><strong>Competitor intelligence:</strong> Monitor competitor pricing, features, and positioning</li><li><strong>News tracking:</strong> Scrape industry news sites for relevant signals</li></ul><h3>Integration Pattern</h3><p>Firecrawl → n8n → Clay → CRM. Use Firecrawl to extract raw data, n8n to orchestrate the flow, Clay to enrich and structure it, then push to your CRM.</p><div class="my-8 p-6 bg-gray-50 rounded-xl border border-gray-200"><h4 class="text-lg font-bold text-gray-900 mb-2">See the stack in action</h4><p class="mb-4 text-sm text-gray-600">Watch a live demo of Clay + n8n + Firecrawl + Exa working together.</p><a href="https://cal.com/jayanand-j-ywq8ls/30min" target="_blank" class="inline-block bg-white border border-gray-300 text-gray-900 px-4 py-2 rounded-lg font-medium hover:bg-gray-50 transition-colors">Book Demo</a></div><h2>Exa AI: The Discovery Engine</h2><p>Exa is a neural search engine built for AI agents. Unlike Google, it's designed to return structured, relevant results that can be programmatically consumed.</p><h3>What Makes Exa Different</h3><ul><li><strong>Semantic search:</strong> Understands intent, not just keywords</li><li><strong>Structured output:</strong> Returns clean JSON you can immediately use</li><li><strong>Real-time data:</strong> Searches the live web, not a stale index</li><li><strong>AI-native:</strong> Built to be called by agents, not humans</li></ul><h3>GTM Applications</h3><p>1. <strong>Account discovery:</strong> "Find SaaS companies that raised Series A in the last 6 months"<br>2. <strong>Signal detection:</strong> "Show me companies that just hired a VP of Sales"<br>3. <strong>Content research:</strong> "Find recent articles about GTM automation"<br>4. <strong>Competitive analysis:</strong> "List companies offering similar solutions to [competitor]"</p><h2>The Integrated Pipeline</h2><p>Here's how these tools work together in a real-world scenario:</p><h3>Use Case: Automated Outbound for Series B Companies</h3><pre><code>1. Exa AI searches for Series B announcements (daily)
2. n8n receives results and triggers enrichment
3. Clay enriches each company (firmographics, contacts, tech stack)
4. n8n scores leads based on ICP fit
5. Firecrawl extracts company blog posts and news
6. n8n sends to GPT-4 for personalization research
7. Clay generates personalized email copy
8. n8n sends emails via SendGrid
9. All data syncs to HubSpot with full attribution</code></pre><p>This entire pipeline runs automatically, 24/7, with zero manual intervention. It's like having a team of SDRs that never sleep.</p><h2>Implementation Roadmap</h2><h3>Week 1: Foundation</h3><ul><li>Set up n8n (self-hosted or cloud)</li><li>Create Clay account and connect data providers</li><li>Sign up for Firecrawl and Exa AI</li><li>Build your first simple workflow (e.g., company enrichment)</li></ul><h3>Week 2: Integration</h3><ul><li>Connect n8n to Clay via API</li><li>Build Firecrawl scraping templates</li><li>Set up Exa search queries</li><li>Create end-to-end test pipeline</li></ul><h3>Week 3: Production</h3><ul><li>Deploy your first automated workflow</li><li>Set up monitoring and alerts</li><li>Build dashboards to track performance</li><li>Iterate based on results</li></ul><h2>Cost Breakdown</h2><ul><li><strong>Clay:</strong> $349/mo (Growth plan)</li><li><strong>n8n:</strong> Free (self-hosted) or $20/mo (cloud)</li><li><strong>Firecrawl:</strong> $79/mo (Starter)</li><li><strong>Exa AI:</strong> $40/mo (Pro)</li><li><strong>Total:</strong> ~$488/mo</li></ul><p>Compare this to the cost of a single SDR ($60K+/year) and the ROI becomes obvious. This stack can do the work of 5-10 SDRs for less than 10% of the cost.</p><h2>Conclusion</h2><p>The 2025 GTM stack isn't about having more tools—it's about having the right tools working together seamlessly. Clay, n8n, Firecrawl, and Exa AI form the foundation of modern revenue engineering. Master this stack, and you'll have a competitive advantage that compounds over time.</p>`
    }
];

// Read existing resources
const resourcesPath = path.join(__dirname, '../data/resources.json');
const existingResources = JSON.parse(await fs.readFile(resourcesPath, 'utf-8'));

// Merge and write
const allResources = [...existingResources, ...newResources];
await fs.writeFile(resourcesPath, JSON.stringify(allResources, null, 4));

console.log(`Added ${newResources.length} new resources. Total: ${allResources.length}`);
